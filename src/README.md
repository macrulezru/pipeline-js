# Pipeline Framework (src/core/pipeline)

## Описание

Механизм pipeline — это универсальная, расширяемая и типобезопасная система для построения цепочек асинхронных операций (пайплайнов) с поддержкой сложных сценариев обработки данных, HTTP-запросов, прогресса, ошибок и метрик.

Pipeline позволяет описывать последовательность этапов (stages), каждый из которых может выполнять запрос к API, обработку данных, валидацию, агрегацию и т.д. Каждый этап может зависеть от результатов предыдущих, иметь собственные условия выполнения, обработчики ошибок и параметры таймаута/повторов.

## Основные компоненты

- **PipelineOrchestrator** — основной исполнитель пайплайна. Управляет прогрессом, выполняет этапы, обрабатывает ошибки, поддерживает реактивность.
- **PipelineConfig** — декларативное описание этапов пайплайна (массив stages с ключами, функциями-запросами, условиями, retry, timeout и т.д.).
- **RequestExecutor** — унифицированный HTTP-клиент с поддержкой retry, таймаутов, метрик, кэширования, rate-limit и отмены запросов.
- **ProgressTracker** — реактивный трекер прогресса выполнения пайплайна.
- **ErrorHandler** — централизованная обработка ошибок этапов.
- **Типы (types.ts)** — строгая типизация всех этапов, конфигов, результатов, ошибок и прогресса.
- **rest-client.ts** — низкоуровневый HTTP-клиент с интеграцией метрик, кэша, rate-limit и отмены.

## Принципы работы

1. **Декларативность**: pipeline описывается как массив этапов с ключами, функциями-запросами и условиями.
2. **Гибкость**: каждый этап может быть асинхронным, иметь свои retry, timeout, обработчик ошибок, условие выполнения.
3. **Реактивность**: прогресс пайплайна и результаты доступны как реактивные ссылки (ref/computed).
4. **Единый HTTP-стек**: все запросы проходят через RequestExecutor/rest-client, что обеспечивает метрики, кэш, rate-limit, отмену, обработку ошибок и единый стиль логирования.
5. **Типобезопасность**: строгая типизация входов/выходов этапов, результатов, ошибок.
6. **Интеграция с метриками**: все запросы автоматически логируются в metricsBus и доступны для UI/отладки.

## Преимущества pipeline-механизма

- **Единая точка управления логикой и запросами**: все сценарии (от простых до сложных) реализуются через один механизм.
- **Минимум дублирования**: повторное использование этапов, обработчиков, конфигов.
- **Простота тестирования**: каждый этап — чистая функция, легко мокается и тестируется.
- **Гибкая обработка ошибок**: можно задать обработчик на каждый этап или глобально.
- **Реактивный прогресс**: удобно для UI (progress bar, stepper, отмена, повтор).
- **Автоматические метрики**: прозрачный сбор статистики по всем запросам и этапам.
- **Лёгкая интеграция с Vue/Pinia**: pipeline легко встраивается в компоненты и сторы.
- **Расширяемость**: можно добавлять новые типы этапов, плагины, обработчики, интеграции.
- **Безопасность и контроль**: строгая типизация, централизованный контроль ошибок и состояния.

## Пример использования

```ts
import { PipelineOrchestrator } from './pipeline-orchestrator';
import { RequestExecutor } from './request-executor';
import type { PipelineConfig } from './types';

const httpConfig = { ... };
const executor = new RequestExecutor(httpConfig);

const pipelineConfig: PipelineConfig = {
  stages: [
    {
      key: 'step1',
      request: async () => await executor.execute('endpoint1'),
      retryCount: 2,
      timeoutMs: 10000,
    },
    {
      key: 'step2',
      request: async (prev) => await executor.execute(`endpoint2/${prev.id}`),
      condition: prev => !!prev,
    },
    // ...
  ],
};

const orchestrator = new PipelineOrchestrator(pipelineConfig, httpConfig);
const progress = orchestrator.getProgressRef();
const result = await orchestrator.run();
```

## Рекомендации по использованию

- Используйте pipeline для любых цепочек запросов, где важна последовательность, прогресс, обработка ошибок, метрики.
- Для одиночных запросов используйте RequestExecutor напрямую — это даст метрики и унификацию.
- Все новые сценарии API/логики реализуйте через pipeline для единообразия и прозрачности.

---

**Pipeline — это современный, масштабируемый и прозрачный способ построения сложных сценариев работы с API и асинхронными процессами.**

# Pipeline (Конвейерная система) для REST API

Модуль для построения декларативных и динамических цепочек HTTP-запросов с передачей данных между этапами, обработкой ошибок, условиями, пользовательскими паузами и полной типобезопасностью.

---

## Архитектура и назначение

- **PipelineOrchestrator** — управляет последовательностью этапов, передачей данных, прогрессом и ошибками.
- **PipelineConfig** — декларативное описание этапов (шагов) pipeline.
- **PipelineStageConfig** — описание отдельного шага: request, key, condition, retry, timeout, errorHandler.
- **RequestExecutor** — универсальный исполнитель HTTP-запросов (используется, если не задан кастомный request).
- **ProgressTracker** — отслеживает статус каждого этапа.
- **ErrorHandler** — глобальная и локальная обработка ошибок.

---

## Основные возможности

- Последовательное выполнение шагов с передачей результата между ними
- Кастомные request-функции для любого шага (можно реализовать любую логику)
- Автоматическая или условная передача данных между этапами
- Условное выполнение этапов (condition)
- Retry-логика и таймауты на каждом этапе
- Локальная и глобальная обработка ошибок
- Пользовательские паузы между шагами (onStepPause)
- Типобезопасность (TS generics)
- Использование sharedData для глобального состояния

---

## Пример: Динамический pipeline с передачей данных

````ts
import { PipelineOrchestrator } from './pipeline-orchestrator';
import type { PipelineConfig } from './types';

# Pipeline (src/core/pipeline)

Механизм pipeline — это универсальная, расширяемая и типобезопасная система для построения цепочек асинхронных операций (пайплайнов) с поддержкой сложных сценариев обработки данных, HTTP-запросов, прогресса, ошибок и метрик.

---

## Архитектура и ключевые компоненты

- **PipelineOrchestrator** — управляет последовательностью этапов, передачей данных, прогрессом и ошибками.
- **PipelineConfig** — декларативное описание этапов (шагов) pipeline.
- **PipelineStageConfig** — описание отдельного шага: request, key, condition, retry, timeout, errorHandler.
- **RequestExecutor** — универсальный исполнитель HTTP-запросов (используется, если не задан кастомный request).
- **ProgressTracker** — отслеживает статус каждого этапа, реактивный прогресс для UI.
- **ErrorHandler** — глобальная и локальная обработка ошибок.
- **Типы (types.ts)** — строгая типизация всех этапов, конфигов, результатов, ошибок и прогресса.
- **rest-client.ts** — низкоуровневый HTTP-клиент с интеграцией метрик, кэша, rate-limit и отмены.

---

## Преимущества pipeline-механизма

- **Единая точка управления логикой и запросами**: все сценарии (от простых до сложных) реализуются через один механизм.
- **Минимум дублирования**: повторное использование этапов, обработчиков, конфигов.
- **Простота тестирования**: каждый этап — чистая функция, легко мокается и тестируется.
- **Гибкая обработка ошибок**: можно задать обработчик на каждый этап или глобально.
- **Реактивный прогресс**: удобно для UI (progress bar, stepper, отмена, повтор).
- **Автоматические метрики**: прозрачный сбор статистики по всем запросам и этапам.
- **Лёгкая интеграция с Vue/Pinia**: pipeline легко встраивается в компоненты и сторы.
- **Расширяемость**: можно добавлять новые типы этапов, плагины, обработчики, интеграции.
- **Безопасность и контроль**: строгая типизация, централизованный контроль ошибок и состояния.

---

## Основные возможности

- Последовательное выполнение шагов с передачей результата между ними
- Кастомные request-функции для любого шага (можно реализовать любую логику)
- Автоматическая или условная передача данных между этапами
- Условное выполнение этапов (condition)
- Retry-логика и таймауты на каждом этапе
- Локальная и глобальная обработка ошибок
- Пользовательские паузы между шагами (onStepPause)
- Типобезопасность (TS generics)
- Использование sharedData для глобального состояния

---

## Пример: Динамический pipeline с передачей данных

```ts
import { PipelineOrchestrator } from './pipeline-orchestrator';
import type { PipelineConfig } from './types';

const httpConfig = {
  baseURL: 'https://api.macrulez.ru/v1/fly',
  timeout: 10000,
  headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
};

const pipelineConfig: PipelineConfig = {
  stages: [
    {
      // Первый шаг: получить список точек
      request: async () => {
        const resp = await fetch(`${httpConfig.baseURL}/points`, {
          headers: httpConfig.headers,
        });
        const data = await resp.json();
        const { points } = data;
        if (!Array.isArray(points) || points.length === 0) return null;
        const cityObj = points[Math.floor(Math.random() * points.length)];
        const from = cityObj.point_code;
        const departures = cityObj.departure_to?.split(',').filter(Boolean);
        if (!departures || departures.length === 0) return null;
        const to = departures[Math.floor(Math.random() * departures.length)];
        return { points, from, to };
      },
    },
    {
      // Второй шаг: получить availability по from/to из первого шага
      request: async prev => {
        if (!prev?.from || !prev?.to) return null;
        const url = `${httpConfig.baseURL}/availability/${prev.from}/${prev.to}`;
        const resp = await fetch(url, { headers: httpConfig.headers });
        return await resp.json();
      },
      condition: prev => !!prev?.from && !!prev?.to,
    },
  ],
};

const orchestrator = new PipelineOrchestrator(pipelineConfig, httpConfig);
orchestrator.run().then(result => {
  console.log('Результаты:', result.results);
});
````

---

## Описание этапа (PipelineStageConfig)

- `request: (prevResult) => Promise<result>` — основная функция шага. Получает результат предыдущего шага.
- `key: string` — (опционально) идентификатор/маршрут для универсального executor (если не используется кастомный request).
- `condition: (prev, all, shared) => boolean` — (опционально) условие выполнения шага.
- `retryCount: number` — (опционально) количество повторов при ошибке.
- `timeoutMs: number` — (опционально) таймаут шага.
- `errorHandler: (err, key, shared) => any` — (опционально) локальная обработка ошибок.

---

## Как работает orchestrator

1. Идёт по всем stages по порядку.
2. Для каждого шага:
   - Если есть condition и оно false — шаг пропускается.
   - Если есть кастомный request — вызывается он (и получает результат предыдущего шага).
   - Если request не задан, но есть key — используется универсальный executor (rest-клиент).
   - Результат шага передаётся в следующий шаг.
   - Ошибки обрабатываются локально (errorHandler) или глобально.
   - Если задан onStepPause — выполнение приостанавливается для пользовательского подтверждения/редактирования результата.
3. После завершения возвращает { results, errors, success }.

---

## Best practices

- Для динамических шагов всегда используйте кастомный request.
- key нужен только для универсального executor или для идентификации шага.
- Для сложных сценариев используйте sharedData для глобального состояния.
- Всегда обрабатывайте ошибки либо локально (errorHandler), либо глобально.
- Для UI-интеграции используйте ProgressTracker.

---

## Визуализация прогресса

```ts
const progress = orchestrator.progress.getProgress();
// progress.currentStage, progress.stageStatuses
```

---

## Зависимости

- Использует rest-client.ts для HTTP-запросов (axios)
- Не требует сторонних библиотек

---

**Pipeline — современный, масштабируемый и прозрачный способ построения сложных сценариев работы с API и асинхронными процессами.**

**Вопросы и доработки:** Для интеграции с UI или расширения логики — обращайтесь к разработчику модуля.
